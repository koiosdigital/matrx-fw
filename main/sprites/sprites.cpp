#include "sprites.h"

#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

#include "display.h"
#include "static_files.h"  // Will be generated by build system with matrix dimension-specific content

uint8_t* fs_sprite_buf = nullptr;

static const char* TAG = "sprites";

void list_static_images() {
    // This function will be implemented once static_files.h is properly generated
}

void sprite_free(RAMSprite_t* sprite) {
    if (sprite != nullptr) {
        // Take mutex before freeing to ensure no operations are in progress
        if (sprite->mutex != nullptr) {
            xSemaphoreTake(sprite->mutex, portMAX_DELAY);
            // Delete the mutex
            vSemaphoreDelete(sprite->mutex);
            sprite->mutex = nullptr;
        }

        free(sprite->data);
        free(sprite);
    }
}

RAMSprite_t* sprite_allocate() {
    RAMSprite_t* sprite = (RAMSprite_t*)malloc(sizeof(RAMSprite_t));
    if (sprite == nullptr) {
        ESP_LOGE(TAG, "malloc failed: new sprite");
        return nullptr;
    }

    sprite->data = nullptr;
    sprite->len = 0;

    // Create mutex for thread safety
    sprite->mutex = xSemaphoreCreateMutex();
    if (sprite->mutex == nullptr) {
        ESP_LOGE(TAG, "failed to create sprite mutex");
        free(sprite);
        return nullptr;
    }

    return sprite;
}

void sprite_update_data(RAMSprite_t* sprite, const uint8_t* data, size_t len) {
    if (sprite == nullptr || sprite->mutex == nullptr) return;

    if (xSemaphoreTake(sprite->mutex, portMAX_DELAY) != pdTRUE) return;

    if (data == nullptr || len == 0) {
        free(sprite->data);
        sprite->data = nullptr;
        sprite->len = 0;
        xSemaphoreGive(sprite->mutex);
        return;
    }

    free(sprite->data);
    sprite->data = (uint8_t*)heap_caps_calloc(len, sizeof(uint8_t), MALLOC_CAP_SPIRAM);
    if (sprite->data == nullptr) {
        ESP_LOGE(TAG, "Sprite malloc failed (%zu bytes)", len);
        sprite->len = 0;
        xSemaphoreGive(sprite->mutex);
        return;
    }

    memcpy(sprite->data, data, len);
    sprite->len = len;

    xSemaphoreGive(sprite->mutex);
}

void show_fs_sprite(const char* filename) {
    if (filename == nullptr) return;

    const uint8_t* data_ptr = nullptr;
    size_t data_len = 0;

    if (get_image_data(filename, &data_ptr, &data_len) == 0) {
        ESP_LOGD(TAG, "Image not found: %s", filename);
        return;
    }

    display_sprite((uint8_t*)data_ptr, data_len);
}

void show_sprite(RAMSprite_t* sprite) {
    if (sprite == nullptr || sprite->mutex == nullptr) return;

    if (xSemaphoreTake(sprite->mutex, portMAX_DELAY) != pdTRUE) return;

    if (sprite->data == nullptr || sprite->len == 0) {
        xSemaphoreGive(sprite->mutex);
        return;
    }

    // Free any existing buffer
    free(fs_sprite_buf);
    fs_sprite_buf = nullptr;

    // Create a buffer copy of the sprite data
    fs_sprite_buf = (uint8_t*)heap_caps_calloc(sprite->len, sizeof(uint8_t), MALLOC_CAP_SPIRAM);
    if (fs_sprite_buf == nullptr) {
        ESP_LOGE(TAG, "Sprite display malloc failed");
        xSemaphoreGive(sprite->mutex);
        return;
    }

    memcpy(fs_sprite_buf, sprite->data, sprite->len);
    size_t sprite_len = sprite->len;

    xSemaphoreGive(sprite->mutex);

    display_sprite(fs_sprite_buf, sprite_len);
}

void sprites_cleanup() {
    free(fs_sprite_buf);
    fs_sprite_buf = nullptr;
}

// Thread-safe function to get a copy of sprite data
bool sprite_get_data_copy(RAMSprite_t* sprite, uint8_t** data_copy, size_t* len) {
    if (sprite == nullptr || data_copy == nullptr || len == nullptr || sprite->mutex == nullptr) {
        return false;
    }

    if (xSemaphoreTake(sprite->mutex, portMAX_DELAY) != pdTRUE) {
        return false;
    }

    if (sprite->data == nullptr || sprite->len == 0) {
        *data_copy = nullptr;
        *len = 0;
        xSemaphoreGive(sprite->mutex);
        return true;
    }

    *data_copy = (uint8_t*)heap_caps_malloc(sprite->len, MALLOC_CAP_SPIRAM);
    if (*data_copy == nullptr) {
        *len = 0;
        xSemaphoreGive(sprite->mutex);
        return false;
    }

    memcpy(*data_copy, sprite->data, sprite->len);
    *len = sprite->len;

    xSemaphoreGive(sprite->mutex);
    return true;
}

// Thread-safe function to get sprite length
size_t sprite_get_length(RAMSprite_t* sprite) {
    if (sprite == nullptr || sprite->mutex == nullptr) return 0;

    if (xSemaphoreTake(sprite->mutex, portMAX_DELAY) != pdTRUE) return 0;

    size_t len = sprite->len;
    xSemaphoreGive(sprite->mutex);

    return len;
}